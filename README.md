# Threads
 Лабораторные по Параллельному программированию

<!-- TABLE OF CONTENTS -->
<details>
  <summary>Содержание</summary>
  <ol>
    <li><a href="#Лабораторная-1">Лабораторная 1</a>
      <ul>
        <li><a href="#Задание-1">Задание</a></li>
      </ul>
    </li>
    <li><a href="#Лабораторная-2">Лабораторная 2</a>
      <ul>
        <li><a href="#Задание-2">Задание</a></li>
        <li><a href="#Решение-2">Решение</a></li>
      </ul>
    </li>
    <li><a href="#">Лабораторная 3</a></li>
  </ol>
</details>

# Лабораторная 1

## Задание 1
### Реализовать программу и сформировать подробный отчет в свободной форме
Сгенерировать файл, содержащий N натуральных (1, 2, 3…N). Число N подается на вход
Реализуйте последовательную обработку элементов файла, например, умножение элементов на число
Реализуйте многопоточную обработку элементов массива, используя разделение файла на равное число элементов. Число потоков задается параметром M.
Выполните анализ эффективности многопоточной обработки при разных параметрах N (10, 100, 1000, 100 тыс, 1 млн, 10 млн, 100 млн, 1 млрд) и M (1, 2, 3, 4, 5, 10, 20, 30, 100). Результаты представьте в свободной форме, рекомендуемый вариант - табличный.
Выполните анализ эффективности при усложнении обработки каждого элемента массива (к примеру, возведение в степень, факториал, операцию с плавающей  точкой,  подсчет числа Фиббоначи и т.п.).
Исследовать неравномерное разделение элементов по потокам (пример: один поток обрабатывает 10 элементов, а другой - миллион)
 
### Вопросы:
Почему эффект от распараллеливания наблюдается только при большем числе элементов?
Как влияет увеличение сложности обработки на эффективность многопоточной обработки?
Какое число потоков является оптимальным для конкретной вычислительной системы? Как его подобрать? 
Почему неравномерность загрузки потоков приводит к снижению эффективности многопоточной обработки?
Как логичнее всего реализовать обработку таких данных


# Лабораторная 2

## Задание 2

### Последовательный алгоритм "Решето Эратосфена".
Алгоритм заключается в последовательном переборе уже известных простых чисел, начиная с двойки, и проверке разложимости всех чисел диапазона на найденное простое число . На первом шаге выбирается число , проверяется разложимость чисел диапазона на 2-ку. Числа, которые делятся на двойку, помечаются как составные и не участвуют в дальнейшем анализе. Следующим непомеченным (простым) числом будет , и так далее.

![alt text](https://intuit.ru/EDI/25_01_16_3/1453674113-15194/tutorial/1158/objects/6/files/2_1.png)

При этом достаточно проверить разложимость чисел на простые числа в интервале . Например, в интервале от 2 до 20 проверяем все числа на разложимость 2, 3. Составных чисел, которые делятся только на пятерку, в этом диапазоне нет.

### Модифицированный последовательный алгоритм поиска
В последовательном алгоритме "базовые" простые числа определяются поочередно. После тройки следует пятерка, так как четверка исключается при обработке двойки. Последовательность нахождения простых чисел затрудняет распараллеливание алгоритма. В модифицированном алгоритме выделяются два этапа:
1-ый этап: поиск простых чисел в интервале от с помощью классического метода решета Эратосфена (базовые простые числа).
2-ой этап: поиск простых чисел в интервале от , в проверке участвуют базовые простые числа, выявленные на первом этапе.

![alt text](https://intuit.ru/EDI/25_01_16_3/1453674113-15194/tutorial/1158/objects/6/files/2_2.png)

На первом этапе алгоритма выполняется сравнительно небольшой объем работы, поэтому нецелесообразно распараллеливать этот этап. На втором этапе проверяются уже найденные базовые простые числа. Параллельные алгоритмы разрабатываются для второго этапа.

### Параллельный алгоритм №1: декомпозиция по данным

![alt text](https://intuit.ru/EDI/25_01_16_3/1453674113-15194/tutorial/1158/objects/6/files/2_3.png)

Идея распараллеливания заключается в разбиении диапазона на равные части. Каждый поток обрабатывает свою часть чисел, проверяя на разложимость по каждому базовому простому числу.

### Параллельный алгоритм №2: декомпозиция набора простых чисел
![alt text](https://intuit.ru/EDI/25_01_16_3/1453674113-15194/tutorial/1158/objects/6/files/2_4.png)

В этом алгоритме разделяются базовые простые числа. Каждый поток работает с ограниченным набором простых чисел и проверяет весь диапазон.

### Параллельный алгоритм №3: применение пула потоков

Применение пула потоков позволяет автоматизировать обработку независимых рабочих элементов. В качестве рабочих элементов предлагается использовать проверку всех чисел диапазона от на разложимость по одному базовому простому числу.

![alt text](https://intuit.ru/EDI/25_01_16_3/1453674113-15194/tutorial/1158/objects/6/files/2_5.png)

### Параллельный алгоритм №4: последовательный перебор простых чисел
Идея алгоритма заключается в последовательном переборе базовых простых чисел разными потоками. Каждый поток осуществляет проверку всего диапазона на разложимость по определенному простому числу. После обработки первого простого числа поток не завершает работу, а обращается за следующим необработанным простым числом.

![alt text](https://intuit.ru/EDI/25_01_16_3/1453674113-15194/tutorial/1158/objects/6/files/2_6.png)

Для получения текущего простого числа поток выполняет несколько операторов:
     
В этой реализации существует разделяемый ресурс – массив простых чисел. При одновременном доступе к ресурсу возникает проблема гонки данных. Следствием этой проблемы являются: лишняя обработка, если несколько потоков одновременно получают одно и то же число; пропущенная задача - потоки, получив одно число, последовательно увеличивают текущий индекс; исключение "Выход за пределы массива", когда один поток успешно прошел проверку текущего индекса, но перед обращением к элементу массива, другой поток увеличивает текущий индекс.
Для устранения проблем с совместным доступом необходимо использовать средства синхронизации (критические секции, атомарные операторы, потокобезопасные коллекции).

## Решение 2

В проекте **ThreadsProject** к Лабораторной работе 2 относятся файлы **SimpleThread.cs**, **SimpleNumbersClass.cs**,  **SimpleRecordClass.cs**.

**SimpleThread.cs** содержит в себе метод реализующий последовательный алгоритм "Решето Эратосфена", а также метод для обработки массива чисел, вызывающий метод "Решето Эратосфена" и один из методов для параллельной обработки.
**SimpleNumbersClass.cs** содержит в себе методы параллельной обработки массива чисел.
**SimpleRecordClass.cs** вспомогательный класс для передачи нескольких параметров в парарллельные методы.

Из-за того что основной проект **ThreadsProject** является WPF-проектом, появилась проблема связанная с работой ThreadPool и сигнальными сообщениями. Проект WPF не поддерживает добавление нескольких сигнальных сообщений, т.к. это будет мешать основному потоку с UI-интерфейсом. Поэтому при вызове метода **WaitHandle.WaitAll(events);** появляется следующая ошибка:

```System.NotSupportedException: "Метод WaitAll для нескольких дескрипторов в потоке STA не поддерживается."```

Поэтому для реализации Параллельного алгоритма 3 был создан отдельный проект **lab2** в виде консольного приложения. Он не имеет функции записи в файл и реализует только Параллельный алгоритм 3.

Код параллельного алгоритма 3 в основном проекте полностью идентичен коду представленному в проекте **lab2**.

Результаты запусков различных алгоритмов представлены в файле lab2.xlsx 
